#!/usr/bin/perl
# Sysync
# 
# Copyright (C) 2012 Ohio-Pennsylvania Software, LLC.
#
# This file is part of sysync.
# 
# sysync is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
# 
# sysync is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
# 
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

use strict;

use File::Copy;
use Digest::MD5 qw(md5_hex);
use Time::HiRes 'usleep';
use POSIX ":sys_wait_h";

use IPC::Open3;
use YAML;

my $default_sleep = 1800;
my $max_workers   = 10;
my $sysdir        = '/var/sysync';
my $stagedir      = '/var/sysync/stage';

my $editor = $ENV{EDITOR} || 'vi';

die "sysync may only be ran as root\n" unless $< == 0;

my $current_workers = 0;

my @TRAILING_ARGS;
open(LOG, ">/dev/null");
*LOG = *STDERR if $ENV{DEBUG};

sub main
{
    # grab options
    my $options = _parse_options();

    if (my $username = $options->{adduser})
    {
        die "Username must be specified\n" if $username eq '1';
        die "User $username already exists\n" if -e "$sysdir/users/$username.conf";
        slock();
        my $uid = getnextuid();
        incrementuid();
        _write_new_user_template($username, $uid);

        edit_yaml_file("$sysdir/users/$username.conf") if $options->{interactive};
        print "User $username added\n";
        sunlock();
        _touch("$stagedir/.refreshnow");
    }
    elsif (my $username = $options->{edituser})
    {
        die "Username must be specified\n" if $username eq '1';
        die "User $username does not exists\n" unless -e "$sysdir/users/$username.conf";
        slock();
        edit_yaml_file("$sysdir/users/$username.conf");
        sunlock();
        _touch("$stagedir/.refreshnow");
    }
    elsif (my $username = $options->{deluser})
    {
        die "Username must be specified\n" if $username eq '1';
        die "User $username does not exists\n" unless -e "$sysdir/users/$username.conf";
        slock();
        unlink("$sysdir/users/$username.conf");
        print "$username deleted\n";
        sunlock();
        _touch("$stagedir/.refreshnow");
    }
    elsif (my $group = $options->{addgroup})
    {
        die "Group must be specified\n" if $group eq '1';
        die "'all' is an invalid group name\n" if $group eq 'all';
        die "Group $group already exists\n" if -e "$sysdir/groups/$group.conf";
        slock();
        my $gid = getnextuid();
        incrementuid();
        _write_new_group_template($group, $gid);

        edit_yaml_file("$sysdir/groups/$group.conf") if $options->{interactive};
        print "Group $group added\n";
        sunlock();
        _touch("$stagedir/.refreshnow");
    }
    elsif (my $group = $options->{editgroup})
    {
        die "Group must be specified\n" if $group eq '1';
        die "Group $group does not exists\n" unless -e "$sysdir/groups/$group.conf";
        slock();
        edit_yaml_file("$sysdir/groups/$group.conf");
        sunlock();
        _touch("$stagedir/.refreshnow");
    }
    elsif (my $group = $options->{delgroup})
    {
        die "Group must be specified\n" if $group eq '1';
        die "Group $group does not exists\n" unless -e "$sysdir/groups/$group.conf";
        slock();
        unlink("$sysdir/groups/$group.conf");
        print "$group deleted\n";
        sunlock();
        _touch("$stagedir/.refreshnow");
    }
    elsif (my $host = $options->{addhost})
    {
        die "Host must be specified\n" if $host eq '1';
        die "Host $host already exists\n" if -e "$sysdir/hosts/$host.conf";
        slock();

        _write_new_host_template($host);

        edit_yaml_file("$sysdir/hosts/$host.conf") if $options->{interactive};
        print "Host $host added\n";
        sunlock();
        _touch("$stagedir/.refreshnow");
    }
    elsif (my $host = $options->{edithost})
    {
        die "Host must be specified\n" if $host eq '1';
        die "Host $host does not exists\n" unless -e "$sysdir/hosts/$host.conf";
        slock();
        edit_yaml_file("$sysdir/hosts/$host.conf");
        sunlock();
        _touch("$stagedir/.refreshnow");
    }
    elsif (my $host = $options->{delhost})
    {
        die "Host must be specified\n" if $host eq '1';
        die "Host $host does not exists\n" unless -e "$sysdir/hosts/$host.conf";
        slock();
        unlink("$sysdir/hosts/$host.conf");
        print "$host deleted\n";
        sunlock();
        _touch("$stagedir/.refreshnow");
    }
    elsif ($options->{edithosts})
    {
        slock();
        edit_yaml_file("$sysdir/hosts.conf");
        sunlock();
        _touch("$stagedir/.refreshnow");
    }
    elsif ($options->{'refresh-now'})
    {
        _touch("$stagedir/.refreshnow");
        print "Refresh requested.\n";
    }
    elsif ($options->{mkpasswd})
    {
        print _prompt_for_password() . "\n";
    }
    elsif (my $username = $options->{passwd})
    {
        if ($options->{passwd} eq '1')
        {
            die "Please specify a username\n";
        }
        else
        {
            die "user does not exist\n" unless -e "$sysdir/users/$username.conf";
            my $passwd = _prompt_for_password();
            open(F, ">$sysdir/users/$username.passwd");
            print F $passwd;
            close(F);
            print "Successfully updated password for $username\n";
            _touch("$stagedir/.refreshnow");
        }
    }
    elsif (my $username = $options->{usersetpassword})
    {
        die "user does not exist\n" unless -e "$sysdir/users/$username.conf";

        print "Hello $username!\n\n";

        print "Please enter your password: ";

        system('stty','-echo');
        chomp(my $password = <STDIN>);
        system('stty','echo');

        print "\n";
        my $current_pw = _get_file_contents("$sysdir/users/$username.passwd");

        if (crypt($password, $current_pw) eq $current_pw)
        {
            my $passwd = _prompt_for_password();

            open(F, ">$sysdir/users/$username.passwd");
            print F $passwd;
            close(F);
            print "Successfully updated password for $username\n";
            _touch("$stagedir/.refreshnow");
        }
        else
        {
            die "Incorrect password\n";
        }
    }
    elsif ($options->{usersetpasswordauthkeys})
    {
        my $out = '';

        for my $username (_grab_all_users())
        {
            my $user = Load(_get_file_contents("$sysdir/users/$username.conf"));
            for my $key (@{ $user->{ssh_keys} || [] })
            {
                $out .= qq[command="sudo /usr/sbin/sysync --usersetpassword=$username" $key\n];
            }
        }

        print $out;
    }
    elsif (my $host_list = $options->{cmd})
    {
        die "need to specify host\n" if $host eq '1';

        my $hosts = Load(_get_file_contents("$sysdir/hosts.conf")) || {};
        my %pids;

        # make 'all' hosts directive work
        $host_list = join(',', keys(%{$hosts->{hosts} || {}}))
            if $host_list eq 'all' and $hosts->{hosts};

        for my $host (split(',', $host_list))
        {
            die "host does not exist\n" unless -e "$sysdir/hosts/$host.conf";
            die "host $host not mapped to addresses\n" unless $hosts->{hosts}{$host};
        }

        for my $host (split(',', $host_list))
        {
            while ($current_workers >= $max_workers) { usleep(2000) };

            for my $h (@{ $hosts->{hosts}{$host} || [] })
            {
                my $s = join(' ', @TRAILING_ARGS);

                # give pause
                while ($current_workers >= $max_workers) { usleep(2000) };

                if (my $pid = fork())
                {
                    $pids{$pid} = 1;
                    $current_workers++;
                    print STDOUT "starting: [pid: $pid][$host => $h] $s\n";
                }
                else
                {
                    $0 = "sysync-cmd [$host => $h] $s";
                    my $r = _system('ssh', '-carcfour', '-C', "root\@${h}", '-i', 
                                    '/var/sysync/keys/sysync_rsa', @TRAILING_ARGS);

                    print STDOUT "completed: [pid: $$][$host => $h] $s\n";
                    print STDOUT "===STDOUT===\n" if $r->{stdout};
                    print STDOUT $r->{stdout};
                    print STDOUT "===STDERR===\n" if $r->{stderr};
                    print STDOUT $r->{stderr};
                    print STDOUT "===END===\n";

                    exit(0);
                }
            }
        }

        while (keys %pids)
        {
            for my $pid (keys %pids)
            {
                delete $pids{$pid}
                    if waitpid($pid, WNOHANG);
            }
            usleep(2000);
        }
    }
    elsif ($options->{daemon})
    {
        daemon();
    }
    else
    {
        usage();
    }

    return 0;
}

sub _log { my $lt=localtime; print LOG "$lt: $_[0]\n" }

sub _sync_host
{
    my ($host, $address) = @_;

    my @rsync = ('rsync', '-zva', '--copy-unsafe-links',
                 '-e', 'ssh -carcfour -i /var/sysync/keys/sysync_rsa');
    push @rsync, "$stagedir/$host/";
    push @rsync, "$address:/";

    my $r = _system(@rsync);

    if ($r->{status} and $r->{status} > 0)
    {
        _log("$host => $address fail:\n");
        _log($r->{stderr});
    }
    else
    {
        my @lines = split("\n", $r->{stdout});

        my @out_lines;
        for (@lines)
        {
            $_ =~ s/[\n\r]//g;
            next if $_ =~ /^sending /;
            next if $_ =~ /^sent /;
            next if $_ =~ /^total /;
            next if $_ =~ /^Warning: Permanently added/;

            push @out_lines, "$address: $_" if $_;
        }

        @out_lines = grep { $_ } @out_lines;

        if (@out_lines)
        {
            my $files = join("\n", @out_lines);
            _log("rsyncing [$host => $address]\n$files");
        }
    } 

}

sub _system
{
    my @command = @_;
    my($wtr, $rdr, $err);
    my $pid = open3($wtr, $rdr, $err, @command);
    close($wtr);
    waitpid( $pid, 0 );

    my $out = '';
    $out .= $_ while (<$rdr>);

    my $error = '';
    $error .= $_ while (<$err>);

    if ($ENV{VERBOSE})
    {
        my $s = join(' ', @command);
        warn "=== executing: $s ===\n";
        warn "=== stdout ==\n";
        warn "$out\n";
        warn "=== error ==\n";
        warn "$error\n";
        warn "=== end execution ===\n";
    }

    return {
        status => $?,
        stderr => $error,
        stdout => $out,
    };
}

$SIG{CHLD} = \&REAPER;

sub REAPER
{
    my $kid;

    while (($kid = waitpid(-1, &WNOHANG)) > 0)
    { 

    }
    $current_workers--;
    $SIG{CHLD} = \&REAPER;
}


sub daemon
{
    unless ($ENV{DEBUG})
    {
        if (my $pid = fork())
        {
            warn "sysync-daemon started\n";
            _write_file_contents("/var/run/sysync.pid", $pid);
            exit(0);
        }
        else
        {
            # do nothing
        }
    }

    open(LOG, ">>/var/log/sysync.log") unless $ENV{DEBUG};

    _log("Starting sysync daemon.");

    $0 = 'sysync-daemon';

    unlink("$stagedir/.refreshnow")
        if -e "$stagedir/.refreshnow";

    while (1)
    {
        my $hosts = Load(_get_file_contents("$sysdir/hosts.conf")) || {};
        my @hosts = keys %{ $hosts->{hosts} || {} };

        _update_all_hosts($hosts);

        # map hosts to addresses
        my @host_addresses;

        for my $host (@hosts)
        {
            for my $address (@{ $hosts->{hosts}{$host} || [] })
            {
                push @host_addresses, { 
                    host => $host,
                    address => $address,
                };
            }
        }

        for my $h (@host_addresses)
        {
            while ($current_workers >= $max_workers) { usleep(2000) };

            if (fork())
            {
                $current_workers++;
            }
            else
            {
                $0 = "sysync-refresh [$h->{host} => $h->{address}]";
                eval { _sync_host($h->{host}, $h->{address}) };
                if ($@)
                {
                    _log($@);
                }
                exit(0);
            }
        }

        my $sleep_counter = 1;

        while ($sleep_counter <= $default_sleep)
        {
            sleep(1);
            $sleep_counter++;

            if (-e "$stagedir/.refreshnow")
            {
                unlink("$stagedir/.refreshnow");
                last;
            }
        }
    }
}

sub _write_new_user_template
{
    my ($username, $uid) = @_;

    open(F, ">$sysdir/users/$username.conf");
    print F qq{username: $username
uid: $uid
fullname: $username
homedir: /home/$username
shell: /bin/bash
disabled: 0
#gid: (defaults to uid)
#ssh_keys:
#   - "SSH key here"
};
    close(F);

}

sub _write_new_host_template
{
    my ($host) = @_;

    open(F, ">$sysdir/hosts/$host.conf");
    print F q{
#users:
#   - uid: 0
#     username: root
#     homedir: /root
#     shell: /bin/bash
#     password: '$6$928b679b70731fc7$OjB.vI0hI4PWC9ObsudW3ITZMBjo7Rfs6Dd5vQ80XZM0A6NU6EQqIVQAI3T90T5Bz3K9Vfha0cp176IAHaNQQ.'
#     ssh_keys:
#        - here
# only import users from the following groups
# use all for all users
user_groups:
   - all
};
    close(F);

}

sub _write_new_group_template
{
    my ($groupname, $gid) = @_;

    open(F, ">$sysdir/groups/$groupname.conf");
    print F qq{groupname: $groupname
gid: $gid
#users:
#   - userhere
};
    close(F);

}

sub getnextuid { _get_file_contents("$sysdir/.maxuid") || 1001 }

sub incrementuid
{
    my $next = getnextuid() + 1;

    open(F, ">$sysdir/.maxuid");
    print F $next;
    close(F);
}

sub slock { die "lock file exists $sysdir/.lock" if -e "$sysdir/.lock"; `touch $sysdir/.lock` }
sub sunlock { unlink("$sysdir/.lock") } 

sub _touch { open(F, '>'.shift); close(F); }

sub _local_host
{
    open(my $fh, "/etc/hostname");
    my $hostname = <$fh>;
    close($fh);

    $hostname =~ s/\..*$//g;
    $hostname =~ s/[\n\r]//g;

    return $hostname;
}

sub _get_file_contents
{
    my $file = shift;

    open(my $fh, $file);
    my @content = <$fh>;
    close($fh);

    return join('', @content);
}


sub _write_file_contents
{
    my ($file, $data) = @_;

    # check to see if this differs

    if (-e $file)
    {
        if (md5_hex($data) eq md5_hex(_get_file_contents($file)))
        {
            return;
        }
    }

    _log("writing: $file");

    open(F, "> $file") or die $!;
    print F $data;
    close(F);

    return 1;
}

# quick and dirty
sub _parse_options
{
    my %options;

    my @acceptable_options = qw(
        init adduser edituser interactive
        deluser
        addgroup editgroup
        delgroup
        addhost edithost
        delhost
        edithosts
        mkpasswd
        passwd
        usersetpassword
        usersetpasswordauthkeys
        daemon
        cmd
        refresh-now
    );

    my @OPTS = @ARGV;
    while (@OPTS)
    {
        my $arg = shift @OPTS;

        # cleanse all parameters of all unrighteousness
        #   `--` & `-` any parameter shall be removed
        $arg =~ s/^--//;
        $arg =~ s/^-//;

        # does this carry an assignment?
        if ($arg =~ /=/)
        {
            my ($key, $value) = split('=', $arg);

            $options{$key} = $value;

            if ($arg =~ /^cmd\=/)
            {
                @TRAILING_ARGS = @OPTS;
                last;
            }
        }
        else
        {
            $options{$arg} = 1;
        }
    }

    for my $option (keys %options)
    {
        die("[$0] `$option` is an invalid option\n")
            unless (grep { $_ eq $option } @acceptable_options)
    }

    return \%options;
}

sub _prompt_for_password
{
    print "Type new password: ";

    system('stty','-echo');
    chomp(my $password = <STDIN>);
    system('stty','echo');

    print "\n";

    print "Type new password again: ";

    system('stty','-echo');
    chomp(my $password_confirm = <STDIN>);
    system('stty','echo');

    print "\n";

    if ($password eq $password_confirm)
    {
        my $salt = rand() . $$ . rand();
        $salt =~ s/\.//g;
        $salt = '$6$'.md5_hex($salt);

        return crypt($password, $salt);
    }
    else
    {
        warn "Passwords do not match\n";
        exit(2);
    }
}

sub usage
{
    warn "usage: $0 --interactive [command]\n";
    warn "Commands:\n";
    warn "   --adduser=[user]\n";
    warn "   --edituser=[user]\n";
    warn "   --deluser=[user]\n";
    warn "   --addgroup=[group]\n";
    warn "   --editgroup=[group]\n";
    warn "   --delgroup=[group]\n";
    warn "   --addhost=[host]\n";
    warn "   --edithost=[host]\n";
    warn "   --delhost=[host]\n";
    warn "   --edithosts (edit hosts.conf file)\n";
    warn "   --mkpasswd (return password via stdout)\n";
    warn "   --passwd=[user] (set a user's password)\n";
    warn "   --usersetpassword=[user] allow a user to set their own password\n";
    warn "   --usersetpasswordauthkeys returns authorized_keys file for all users to set their password\n";
    warn "   --daemon (run in daemon mode)\n";
    warn "   --cmd=[host,host2] [command]\n";
    warn "   --refresh-now (by default, sysync-daemon syncs everything every 30 minutes, this forces a refresh)\n";
}

sub edit_yaml_file
{
    my ($file) = @_;
    my $tmp_file = md5_hex(rand() . $$ . rand());
    copy($file, "/tmp/$tmp_file");
    system($editor, "/tmp/$tmp_file");

    do {
        eval { Load(_get_file_contents("/tmp/$tmp_file")) };
        if ($@)
        {
            print "Unable to parse file contents, please re-edit: $@\n";
            print "Want to edit? [Y/n] ";
            chomp(my $r = <STDIN>);

            if ($r =~ /y/i)
            {
                system($editor, "/tmp/$tmp_file");
            }
            else
            {
                unlink("/tmp/$tmp_file");
                sunlock();
                die "Aborted\n";
            }
        }
    } while $@;

    move("/tmp/$tmp_file", $file);
}

exit __PACKAGE__->main;


=head1 COPYRIGHT

2012 Ohio-Pennsylvania Software, LLC.

=head1 LICENSE

 Copyright (C) 2012 Ohio-Pennsylvania Software, LLC.

 This file is part of Sysync.
 
 Sysync is free software: you can redistribute it and/or modify
 it under the terms of the GNU Affero General Public License as
 published by the Free Software Foundation, either version 3 of the
 License, or (at your option) any later version.
 
 Sysync is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU Affero General Public License for more details.
 
 You should have received a copy of the GNU Affero General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.

=head1 AUTHOR

Michael J. Flickinger, C<< <mjflick@gnu.org> >>

=cut

